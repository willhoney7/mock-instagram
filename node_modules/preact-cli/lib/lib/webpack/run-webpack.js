'use strict';

exports.__esModule = true;
exports.showStats = showStats;
exports.writeJsonStats = writeJsonStats;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs.promised');

var _fs2 = _interopRequireDefault(_fs);

var _ip = require('ip');

var _ip2 = _interopRequireDefault(_ip);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _webpackDevServer = require('webpack-dev-server');

var _webpackDevServer2 = _interopRequireDefault(_webpackDevServer);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _getPort = require('get-port');

var _getPort2 = _interopRequireDefault(_getPort);

var _webpackClientConfig = require('./webpack-client-config');

var _webpackClientConfig2 = _interopRequireDefault(_webpackClientConfig);

var _webpackServerConfig = require('./webpack-server-config');

var _webpackServerConfig2 = _interopRequireDefault(_webpackServerConfig);

var _transformConfig = require('./transform-config');

var _transformConfig2 = _interopRequireDefault(_transformConfig);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (() => {
	var _ref = _asyncToGenerator(function* (watch = false, env, onprogress) {
		if (watch) {
			return yield devBuild(env, onprogress);
		}

		return yield prodBuild(env);
	});

	return function () {
		return _ref.apply(this, arguments);
	};
})();

const devBuild = (() => {
	var _ref2 = _asyncToGenerator(function* (env, onprogress) {
		let config = (0, _webpackClientConfig2.default)(env);
		yield (0, _transformConfig2.default)(env, config);

		let userPort = parseInt(process.env.PORT || config.devServer.port, 10) || 8080;
		let port = yield (0, _getPort2.default)(userPort);

		let compiler = (0, _webpack2.default)(config);
		return yield new Promise(function (resolve, reject) {

			compiler.plugin('emit', function (compilation, callback) {
				var missingDeps = compilation.missingDependencies;
				var nodeModulesPath = _path2.default.resolve(__dirname, '../../../node_modules');

				if (missingDeps.some(function (file) {
					return file.indexOf(nodeModulesPath) !== -1;
				})) {
					compilation.contextDependencies.push(nodeModulesPath);
				}

				callback();
			});

			compiler.plugin('done', function (stats) {
				let devServer = config.devServer;

				let protocol = devServer.https ? 'https' : 'http';
				let host = process.env.HOST || devServer.host || 'localhost';

				let serverAddr = `${protocol}://${host}:${_chalk2.default.bold(port)}`;
				let localIpAddr = `${protocol}://${_ip2.default.address()}:${_chalk2.default.bold(port)}`;

				clearConsole();
				if (stats.hasErrors()) {
					process.stdout.write(_chalk2.default.red('\Build failed!\n\n'));
				} else {
					process.stdout.write(_chalk2.default.green('\nCompiled successfully!\n\n'));

					if (userPort !== port) {
						process.stdout.write(`Port ${_chalk2.default.bold(userPort)} is in use, using ${_chalk2.default.bold(port)} instead\n\n`);
					}
					process.stdout.write('You can view the application in browser.\n\n');
					process.stdout.write(`${_chalk2.default.bold('Local:')}            ${serverAddr}\n`);
					process.stdout.write(`${_chalk2.default.bold('On Your Network:')}  ${localIpAddr}\n`);
				}

				if (onprogress) onprogress(stats);
			});
			compiler.plugin('failed', reject);

			let server = new _webpackDevServer2.default(compiler, config.devServer);
			server.listen(port);
		});
	});

	return function devBuild(_x, _x2) {
		return _ref2.apply(this, arguments);
	};
})();

const prodBuild = (() => {
	var _ref3 = _asyncToGenerator(function* (env) {
		let config = (0, _webpackClientConfig2.default)(env);

		yield (0, _transformConfig2.default)(env, config);
		let serverCompiler,
		    clientCompiler = (0, _webpack2.default)(config);

		if (env.prerender) {
			let ssrConfig = (0, _webpackServerConfig2.default)(env);
			yield (0, _transformConfig2.default)(env, ssrConfig, true);
			serverCompiler = (0, _webpack2.default)(ssrConfig);
			yield runCompiler(serverCompiler);
		}

		let stats = yield runCompiler(clientCompiler);

		yield new Promise(function (r) {
			return setTimeout(function () {
				return r();
			}, 20);
		});

		return stats;
	});

	return function prodBuild(_x3) {
		return _ref3.apply(this, arguments);
	};
})();

const runCompiler = compiler => new Promise((resolve, reject) => {
	compiler.run((err, stats) => {
		if (err || stats.hasErrors()) {
			showStats(stats);
			reject(_chalk2.default.red('Build failed!'));
		}

		resolve(stats);
	});
});

function showStats(stats) {
	let info = stats.toJson("errors-only");

	if (stats.hasErrors()) {
		info.errors.map(stripBabelLoaderPrefix).forEach(message => {
			process.stderr.write(_chalk2.default.red(message) + '\n');
		});
	}

	if (stats.hasWarnings()) {
		info.warnings.map(stripBabelLoaderPrefix).forEach(message => {
			process.stderr.write(_chalk2.default.yellow(message) + '\n');
		});
	}

	return stats;
}

function writeJsonStats(stats) {
	let outputPath = _path2.default.resolve(process.cwd(), 'stats.json');
	let jsonStats = stats.toJson({
		json: true,
		chunkModules: true,
		source: false
	});

	jsonStats = jsonStats.children && jsonStats.children[0] || jsonStats;

	jsonStats.modules.forEach(stripBabelLoaderFromModuleNames);
	jsonStats.chunks.forEach(c => c.modules.forEach(stripBabelLoaderFromModuleNames));

	return _fs2.default.writeFile(outputPath, JSON.stringify(jsonStats)).then(() => {
		process.stdout.write('\nWebpack output stats generated.\n\n');
		process.stdout.write('You can upload your stats.json to:\n');
		process.stdout.write('- https://chrisbateman.github.io/webpack-visualizer/\n');
		process.stdout.write('- https://webpack.github.io/analyse/\n');
	});
}

const clearConsole = () => {
	process.stdout.write(process.platform === 'win32' ? '\x1Bc' : '\x1B[2J\x1B[3J\x1B[H');
};

const stripBabelLoaderFromModuleNames = m => {
	const keysToNormalize = ['identifier', 'name', 'module', 'moduleName', 'moduleIdentifier'];

	keysToNormalize.forEach(key => {
		if (key in m) {
			m[key] = stripBabelLoaderPrefix(m[key]);
		}
	});

	if (m.reasons) {
		m.reasons.forEach(stripBabelLoaderFromModuleNames);
	}

	return m;
};

const stripBabelLoaderPrefix = log => log.replace(/@?\s*(\.\/~\/babel-loader\/lib\?{[\s\S]*?}!)/g, '');